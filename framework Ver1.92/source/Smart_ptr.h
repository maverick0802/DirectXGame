//**************************************************
//* Name     : CSmart_ptrクラス
//* Other    : 杉浦　宏紀
//* MakeDate : 2015/11/3 
//*
//* -----概要-----
//* あの、あのスマートポインタでっせ先生！
//* 動的確保したメモリを勝手に消してくれる
//* あのスマートポインタ大先生ですよ
//* テンプレートクラスだから何でも対応してまっせ
//* まぁ参照カウンターは参照先がなくても１だから
//* 勝手にデリートはされないけどねｗｗｗ
//* でもNULLは保証されてるからチェックすればおｋ
//**************************************************

#pragma once
#include<Windows.h>

#ifdef _DEBUG
#define	DEBUG_NEW	new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

template <class Type>

class CSmart_ptr
{
	UINT* m_nRefCnt;		//参照カウンター
	Type* m_pPtr;			//参照先ポインタ

public:


////////////////////////////////////////////////////
//参照カウンター加算
////////////////////////////////////////////////////
	void AddRef(){
	
		(*m_nRefCnt)++;
	
	}

////////////////////////////////////////////////////
//参照カウンター減少
////////////////////////////////////////////////////
	void Release(){
	
		if (--(*m_nRefCnt) == 0)	//デストラクタが前だから式の評価前に
		{							//参照カウンターの減算される
			delete m_pPtr;		//んでゼロなら参照先がないからデリート
			delete	 m_nRefCnt;		//参照カウンターもデリート

			m_pPtr    = NULL;
			m_nRefCnt = NULL;

			//printf("オブジェクト削除完了");

		}
	
	}


////////////////////////////////////////////////////
//デフォルトコンストラクタ
////////////////////////////////////////////////////
	explicit CSmart_ptr(Type* src = NULL,int nAdd = 0){
	
		m_nRefCnt  = new UINT;		//参照カウンターのメモリを確保
		*m_nRefCnt = nAdd;			//初期化
		m_pPtr = src;				//ポインタの初期化
		AddRef();					//参照カウンターの加算
		//printf("デフォルトコンストラクタ通過");
	
	}

////////////////////////////////////////////////////
//コピーコンストラクタ（同型純粋コピー）
////////////////////////////////////////////////////
	CSmart_ptr(const CSmart_ptr<Type> &src){
	
		m_nRefCnt = src.m_nRefCnt;
		m_pPtr    = src.m_pPtr;

		AddRef();
		//printf("コピーコンストラクタ通過");
	
	}

////////////////////////////////////////////////////
//コピーコンストラクタ（暗黙のアップキャスト対応）
////////////////////////////////////////////////////
	template <class Type_Sub> CSmart_ptr(CSmart_ptr<Type_Sub>& temp){

		m_pPtr = temp.GetPtr();			
		m_nRefCnt = temp.GetRefCnt();

		AddRef();
		//printf("コピーコンストラクタ通過");

	}
//デストラクタ
	virtual ~CSmart_ptr(){

		//printf("デストラクタ通過");	
		Release();
	
	}

//■■■■■■■■■■■■■■■■■■■■■■■
//■　　　　　演算子のオーバーロード　　　　　■
//■■■■■■■■■■■■■■■■■■■■■■■

/////////////////////////////////////////////////
//
// 関数名 : operator =（明示的コピー）
// 戻り値 : CSmart_ptr&
// 引数   : const CSmart_ptr<Type>
//
// *********************************************
// <概要>
// スマートポインタ同士の代入演算子のオーバーロード
// 参照カウンター等々の処理が必要
//
/////////////////////////////////////////////////
	CSmart_ptr<Type>& operator=(const CSmart_ptr<Type>& src){
	
		if (src.m_pPtr == m_pPtr)	//同じもの同士なら終わりｗ
			return (*this);

		Release();					//すでに何か持っている可能性があるから
									//参照カウンター減らしておく

		m_nRefCnt = src.m_nRefCnt;	//参照カウンターを譲渡
		m_pPtr = src.m_pPtr;		//参照先を譲渡

		AddRef();					//参照先が増えたから加算

		return (*this);
	}


/////////////////////////////////////////////////
//
// 関数名 : operator = (アップキャスト対応)
// 戻り値 : CSmart_ptr&
// 引数   : const CSmart_ptr<Type>
//
// *********************************************
// <概要>
// スマートポインタ同士の代入演算子のオーバーロード
// 参照カウンター等々の処理が必要
// 内容は↑の関数と同じ
//
/////////////////////////////////////////////////

	template <class Type_Sub> CSmart_ptr& operator=(CSmart_ptr<Type_Sub>& temp){
	

		if (temp.GetPtr() == m_pPtr)
			return (*this);

		Release();

		m_nRefCnt = temp.GetRefCnt();
		m_pPtr    = temp.GetPtr();

		AddRef();

		return (*this);
	
	}


/////////////////////////////////////////////////
//
// 関数名 : operator -> 
// 戻り値 : Type*
// 引数   : なし
//
// *********************************************
// <概要>
// スマートポインタ同士のアロー演算子のオーバーロード
// 何とポインタ以外でも使えちゃうのだｗ
//
/////////////////////////////////////////////////
	Type* operator->(){ return m_pPtr; }	


/////////////////////////////////////////////////
//
// 関数名 : operator * 
// 戻り値 : Type&
// 引数   : なし
//
// *********************************************
// <概要>
// スマートポインタ同士の間接演算子のオーバーロード
//
/////////////////////////////////////////////////
	Type& operator*(){ return *m_pPtr; }


/////////////////////////////////////////////////
//
// 関数名 : operator [] 
// 戻り値 : Type&
// 引数   : int
//
// *********************************************
// <概要>
// スマートポインタ同士の添字演算子のオーバーロード
//
/////////////////////////////////////////////////
	Type& operator[](int nCnt){ return m_pPtr[nCnt]; }	//配列の指定した位置を返す	


/////////////////////////////////////////////////
//
// 関数名 : operator == 
// 戻り値 : BOOL
// 引数   : int
//
// *********************************************
// <概要>
// スマートポインタ同士の等価演算子のオーバーロード
//
/////////////////////////////////////////////////
	BOOL  operator==(int nAddress){
	
		if (m_pPtr == nAddress)		//アドレスの比較
			return TRUE;			//住所一緒なんだから一緒でしょ
		return FALSE;
	
	}


/////////////////////////////////////////////////
//
// 関数名 : operator != 
// 戻り値 : BOOL
// 引数   : int
//
// *********************************************
// <概要>
// スマートポインタ同士の不等価演算子のオーバーロード
//
/////////////////////////////////////////////////
	BOOL  operator!=(int nAddress){

		if (m_pPtr != nAddress)		//アドレスの比較
			return TRUE;			//住所違ったら違うでしょ
		return FALSE;

	}

//■■■■■■■■■■■■■■■■■■■■■■■
//■　　　　　　　メンバ関数　　　　　　　　　■
//■■■■■■■■■■■■■■■■■■■■■■■


/////////////////////////////////////////////////
//
// 関数名:GetPtr()
// 戻り値:Type*
// 引数  :無し
//
// *********************************************
// <概要>
// スマートポインタの受け取ったポインタを貸し出す
//
/////////////////////////////////////////////////
	Type* GetPtr(){ return m_pPtr; }


/////////////////////////////////////////////////
//
// 関数名 : GetRefCnt()
// 戻り値 : UINT*
// 引数   : 無し
//
// *********************************************
// <概要>
// 参照カウンターを渡す
//
/////////////////////////////////////////////////
	UINT* GetRefCnt(){ return (m_nRefCnt); }	

/////////////////////////////////////////////////
//
// 関数名 : SetPtr()
// 戻り値 : 無し
// 引数   : T* 
//	        int
//
// *********************************************
// <概要>
// ポインタの明示的な登録
//
/////////////////////////////////////////////////
	void SetPtr(Type* src = NULL, int nAdd = 0)	
	{
		Release();					//新しいデータを入れるなら
									//今持ってる参照カウンターは減らしましょうね
		m_nRefCnt  = new UINT;		//新しい参照先もらうから新しいメモリを割り当てましょう
		*m_nRefCnt = nAdd;			//参照カウンター指定されたらいれましょう（まぁ初期化ですわ）
		m_pPtr	   = src;			//参照先を入れましょう
		
		AddRef();					//参照カウンターを加算するよ
	
	}

};

